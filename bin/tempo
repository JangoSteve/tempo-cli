#!/usr/bin/env ruby
require 'gli'
begin # XXX: Remove this begin/rescue before distributing your app
require 'tempo'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/tempo` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/tempo now"
  exit 64
end

include GLI::App

program_desc 'Command line time tracking by project'

version Tempo::VERSION

# GLOBAL OPTIONS

desc 'verbose output'
switch [:v,:verbose]

desc 'Describe some flag here'
default_value 'the default'
arg_name 'The name of the argument'
flag [:f,:flagname]

# COMMAND: PROJECT

desc 'Manage the Projects that timed tasks are assigned to'
long_desc "By default, lists all the projects that a timed task can be assigned to.\n
One project at any time will be the active project, and can't be deleted until
the the active project is changed to another project.\n
Projects can be added, and deleted. In the current version, projects cannot be nested."
arg_name '"name of the project"'
command [:project, :p] do |c|

  c.desc 'List Projects'
  c.switch [:l, :ls, :list]

  c.desc 'Add a new Project'
  c.switch [:a, :add]

  c.desc 'Delete a Project'
  c.switch [:d, :delete]

  c.desc 'Change to another Project'
  c.switch [:c,:change]

  c.action do |global_options,options,args|

    #Load Projects
    projects = ['a','b','c','d']
    current_project = 'a'

    project = ""
    args.each { |a| project += " #{a}" }
    project.strip!

    if global_options[:v]
      puts "global_options: #{global_options}"
      puts "options: #{options}"
      puts "args: #{args}"
    end

    if options[:delete]
      # make sure other flags are ignored if included
      options[:change] = false
      options[:add] = false

      raise "cannot delete the active project" if project == current_project

      projects.delete(project) if projects.include?(project)
    end

    if options[:add]
      if projects.include? project
        raise "project #{project} already exists"
      else
        projects << project
      end
    end

    if options[:change]
      if projects.include? project
        current_project = project
      else
        raise "no project '#{project}' exists"
      end
    end

    if options[:list]
      projects.each do |p|
        if p == current_project
          puts "* #{p}"
        else
          puts "  #{p}"
        end
      end
    else
      if options[:change]
        puts "active project changed to '#{current_project}'"
      elsif options[:add]
        puts "added project '#{project}'"
      elsif options[:delete]
        puts "deleted project '#{project}'"
      else
        puts current_project
      end
    end
  end
end

desc 'Describe begin here'
arg_name 'Describe arguments to begin here'
command :begin do |c|
  c.action do |global_options,options,args|
    puts "begin command ran"
  end
end

desc 'Describe end here'
arg_name 'Describe arguments to end here'
command :end do |c|
  c.action do |global_options,options,args|
    puts "end command ran"
  end
end

desc 'Describe report here'
arg_name 'Describe arguments to report here'
command :report do |c|
  c.action do |global_options,options,args|
    puts "report command ran"
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
